\chapter{Implementation}

As has been explained before, the implementation should be a .NET library usable from C\#. While it would be possible to write such a library in another .NET language, C\#, as a general-purpose programming language, is suitable for this task, so it is the language used in the implementation.

One of the principles of the design of the system has been a focus on performance, especially when it comes to limiting executing the code of transformations. The implementation also sometimes considers performance, but generally speaking, maintainability and readability of code take precedence, especially at the method level. Because some of the code written this way might be performance-critical, the intention is to use profiling and optimize the found bottlenecks, but this has not been done in the current version.

\medskip

The implementation of the system is composed of four main projects:

\begin{itemize}
\item \cs{CSharpE.Syntax}, for representing code,
\item \cs{CSharpE.Transform}, for transforming code,
\item \cs{CSharpE.Transform.VisualStudio}, which supports using extensions at design-time in Visual Studio,
\item \cs{CSharpE.Transform.MSBuild}, which supports using extensions at build-time in MSBuild.
\end{itemize}

\section{CSharpE.Syntax}

The most complicated part of the job of \cs{CSharpE.Syntax} is to convert from C\# source code to CSharpE code representation and vice versa. To help with this, we can use Roslyn. Thanks to Roslyn, it is only necessary to write code that converts between the Roslyn representation and the CSharpE representation, which is much easier. Also, by using Roslyn, we use the same code as the C\# compiler, which means there is no chance of introducing parsing bugs.

\medskip

Because CSharpE syntax nodes and Roslyn syntax nodes often have very close correspondence and because transformations often access only some parts of the syntax tree, a CSharpE syntax tree that is created from a Roslyn syntax tree acts as a lazy wrapper over it: CSharpE nodes are created from the corresponding Roslyn nodes only as necessary. In other words, when a CSharpE node is created from a Roslyn node, it stores the Roslyn node. When one of its child nodes is then accessed for the first time, it is created from the corresponding child of the Roslyn node.

Syntax nodes can also have properties that are not child syntax nodes and are not lazy. For example, the property \cs{string Name} of \cs{TypeDefinition} is one.

\medskip

After a CSharpE syntax node is created, it can then be modified by the user. Eventually, it will need to be converted back to C\# source code, which is once more done through Roslyn nodes: CSharpE nodes implement the internal interface \cs{ISyntaxWrapper<TSyntax>}, which can be seen in Listing~\ref{isyntaxwrapper}. The single method of this interface, \cs{GetWrapped}, is used to retrieve an up-to-date version of the Roslyn node (\cs{TSyntax}) for a CSharpE node. The \cs{changed} parameter is used by the \cs{GetWrapped} method of the parent node to detect whether the current node changed since the parent called the \cs{GetWrapped} method of the child node last. Any other caller is required to pass a reference to \cs{null} for the parameter.

\begin{listing}
\begin{minted}{csharp}
internal interface ISyntaxWrapper<out TSyntax>
{
    TSyntax GetWrapped(ref bool? changed);
}
\end{minted}
\caption{Declaration of the ISyntaxWrapper interface}
\label{isyntaxwrapper}
\end{listing}

Another option would be to notify ancestor nodes whenever a node is modified. This way, a node that has not changed would not have to be inspected for changes, which could be more efficient. Though this approach is more complicated and so it has not been implemented.

\medskip

\begin{listing}
\begin{minted}{csharp}
public sealed class Argument : SyntaxNode, ISyntaxWrapper<ArgumentSyntax>
{
    private ArgumentSyntax syntax;

    internal Argument(ArgumentSyntax syntax, SyntaxNode parent)
    {
        this.syntax = syntax ?? throw new ArgumentNullException(nameof(syntax));
        Name = syntax.NameColon?.Name.Identifier.ValueText;
        Parent = parent;
    }

    public Argument(Expression expression, string name = null)
    {
        Expression = expression;
        Name = name;
    }

    public string Name { get; set; }

    private Expression expression;
    public Expression Expression
    {
        get => expression ??
            (expression = FromRoslyn.Expression(syntax.Expression, this));
        set => SetNotNull(ref expression, value);
    }

    ArgumentSyntax ISyntaxWrapper<ArgumentSyntax>.GetWrapped(ref bool? changed)
    {
        GetAndResetChanged(ref changed);
        
        bool? thisChanged = false;
        var newExpression =
            expression?.GetWrapped(ref thisChanged) ?? syntax.Expression;

        if (syntax == null || thisChanged == true ||
            syntax.NameColon?.Name.Identifier.ValueText != Name)
        {
            syntax = RoslynSyntaxFactory.Argument(
                Name == null ? null : CSharpSyntaxFactory.NameColon(Name),
                default, newExpression);

            SetChanged(ref changed);
        }

        return syntax;
    }

    public static implicit operator Argument(Expression expression)
        => new Argument(expression);
}
\end{minted}
\caption{Simplified implementation of the Argument class}
\label{argument-source}
\end{listing}

Listing~\ref{argument-source} shows how a typical implementation of a \cs{SyntaxNode} looks like. Specifically, it shows simplified code of the \cs{Argument} class, which is used to represent an argument to a call. For example, the statement \cs{F(42, foo: null);} contains two arguments: \cs{42} and \cs{foo: null}. An argument is composed of an expression, an optional name and an optional ref kind (\cs{ref}, \cs{out} or \cs{in}). For brevity, the version of \cs{Argument} shown here does not support arguments that have a ref kind. This means that the class has two properties: the lazy \cs{Expression} and the non-lazy \cs{Name}.

The implementation is composed of the following parts:

\begin{itemize}
\item Specification that the class directly inherits from the \cs{SyntaxNode} base class and that it implements the \cs{ISyntaxWrapper<TSyntax>} interface for Roslyn's \cs{ArgumentSyntax} type.

\item A field holding the most recent Roslyn syntax node, if any.

\item An internal constructor that creates an instance of the class from a Roslyn syntax node.

Notice that the lazy property \cs{Expression} is not initialized here, while the non-lazy property \cs{Name} is. Another interesting point is how complicated the expression used to initialize \cs{Name} is, which shows that the CSharpE design is much simpler than the Roslyn design in this case.

This constructor is used when a member of the \cs{Arguments} collection of \cs{InvocationExpression} or a similar kind of expression is accessed for the first time.

\item A public constructor that can be used by the user to create a new instance of this class.

\item The \cs{Name} property.

Because it is not lazy, it does not require any special behavior and so it can be an auto-property.

\item The \cs{Expression} property.

Since it is lazy, when its value is read for the first time, the \cs{Expression} node is created based on the expression of the Roslyn node. The \cs{FromRoslyn} class contains helper methods for converting Roslyn nodes to CSharpE nodes. In this case, it is used to create the correct type that derives from \cs{Expression} based on the Roslyn node.

The setter uses the helper method \cs{SetNotNull}, which checks that the passed in value is not \cs{null} and also ensures that the \cs{Parent} property of the expression node is correctly set. (The \cs{Parent} property is explained in more detail later.)

\item The \cs{GetWrapped} method.

It is an explicit interface implementation, because C\# does not allow implicit interface implementations through internal methods, only public ones, and this method should not be accessible by the user.

The method does the following:

\begin{enumerate}
\item Make sure that the value of the \cs{changed} parameter is set correctly when this method is called by the parent node by invoking the helper methods \cs{GetAndResetChanged} and \cs{SetChanged} at the appropriate places.
\item Call \cs{GetWrapped} on its lazy properties if they are initialized, otherwise use the corresponding child of the saved Roslyn node. While doing this, keep track of whether any lazy properties reported changes in the \cs{thisChanged} variable.
\item Check if a new Roslyn node needs to be created. This happens either because no Roslyn node has been created yet, or because changes occurred since the saved Roslyn node was created. Changes are detected by checking the \cs{thisChanged} variable for lazy properties and by comparing with the latest Roslyn node for non-lazy properties.
\item Create a new Roslyn node by using a factory method from the Roslyn \cs{SyntaxFactory} class (aliased as \cs{RoslynSyntaxFactory} because of a conflict with CSharpE \cs{SyntaxFactory}) and save it.
\item Finally, return the Roslyn node, which is now guaranteed to be up to date.
\end{enumerate}

Note that the returned Roslyn node will have no parent. When the caller is the CSharpE parent node, it will incorporate that Roslyn node into its own Roslyn node, but with parent set to that node. This happens automatically when any Roslyn node with child nodes is created.

To make this efficient, Roslyn uses a data structure called "red-green tree" (unrelated to the well-known red-black tree), where the regular nodes (which have parent references, and so cannot be reused) are a layer on top of hidden nodes with no parent references, which are reused. \cite{red-green-trees}

\item An implicit conversion operator from \cs{Expression} to \cs{Argument}.

\nopagebreak

This way, the common case where an argument has only an expression, without a name or a ref kind, can be created more easily.
\end{itemize}

Other syntax nodes generally follow this pattern, with some exceptions:

\begin{itemize}
\item Accessing any semantic information is more complicated.

As explained in Section~\ref{roslyn}, Roslyn provides semantic information though the \cs{Compilation} and \cs{SemanticModel} classes. For example, to get the full name of a \cs{NamedTypeReference}, such as the type reference \cs{Task} in the field declaration \cs{Task t;}, the following happens:

\begin{enumerate}
\item The \cs{Compilation} for the project is created.

To do that, information from the whole project is necessary, which means that every node that exposes semantic information has to have access to the \cs{Project} object. The way this is done is by making every node have a reference to its parent node. With that, the \cs{SourceFile} that contains a node can be found by recursively walking parent references, and \cs{SourceFile} contains a reference to its \cs{Project}.

\item The \cs{SemanticModel} for the source file is created.

\item A symbol corresponding to the node in question is retrieved from the \cs{SemanticModel}.

This requires using exactly the node that is part of the Roslyn syntax tree that was used to create the \cs{Compilation}. As explained above, the node created by \cs{GetWrapped} is not that: it has no parent node, and so it couldn't possibly be part of the syntax tree.

To find the corresponding node that is part of the syntax tree, we use Roslyn Syntax Annotations. \cite{roslyn-annotations} The Roslyn node returned from \cs{GetWrapped} is annotated with an annotation unique for the current CSharpE node. Then, a node with the same annotation is found in the syntax tree. Finally, that node is used to find the symbol through \cs{SemanticModel}. This works, because incorporating Roslyn node into a parent preserves annotations.

\item The symbol is used to find the desired information.

In this case, that is the full name of the type of the field declaration, which could be (depending on references in the compilation and using directives in the file) for example \cs{System.Threading.Tasks.Task}, \cs{Microsoft.Build.Utilities.Task} or even a type with a name other than \cs{Task} (if the file contains a using alias directive).

\end{enumerate}

\item Lists of syntax nodes have their own set of types.

In the CSharpE \ac{API}, lists of syntax nodes are represented as \cs{IList<T>}. In Roslyn, such lists are either a \cs{SyntaxList<T>} (for lists with no separator, such as members of a class) or a \cs{SeparatedSyntaxList<T>} (for lists that use comma as a separator, such as arguments of a method call).

To bridge this, CSharpE contains a set of internal list types, that also help with maintaining laziness. Such a list contains a collection, where each item can be either a Roslyn node or a CSharpE node. When an item in the list is accessed, it is converted to a CSharpE node, if it is not one already. When \cs{GetWrapped} is called on the list, the result will include Roslyn nodes from the collection directly, while CSharpE nodes have to be converted by invoking their own \cs{GetWrapped}.

\item Exposed collections implement an interface for use in CSharpE.Transform smart loops.

As explained in Section~\ref{smart-loop-collection}, CSharpE.Transform smart loops need to understand the collections they are iterating. For this reason, CSharpE.Syntax collections implement the \cs{ISyntaxCollection<T>} interface. This interface implements the visitor patterns, so that a smart loop can correctly decide how to process the collection.

\item Whitespace from user code is not preserved.

When a syntax node is created using the Roslyn \cs{SyntaxFactory}, it contains so called "elastic trivia", which is meant to be later replaced with proper trivia based on some formatting conventions. But if this step is not performed and the node is converted to a string, the result is invalid code. For example, \cs{SyntaxFactory.ClassDeclaration("Foo").ToString()} returns \cs{classFoo{}}, which is not valid C\# code, because there is nothing separating the tokens \cs{class} and \cs{Foo}.

The easiest way to fix this is to call \cs{NormalizeWhitespace()}, though using that has the side-effect of reformatting all code, including code originally written by the user. But because the user is only ever going to see the reformatted code when debugging (as explained in Section~\ref{debugging}), this was considered an acceptable solution.
\end{itemize}

\section{CSharpE.Transform}

Now that types necessary for representing and modifying code have been implemented, it is time to turn to code that will drive transformations. While Section~\ref{transform-design} described the user-facing \ac{API} of CSharpE.Transform, there is one more public type, \cs{ProjectTransformer}, which is used by the Visual Studio and MSBuild extensions to run transformations. To isolate this type from user-facing types, it is placed in a separate namespace: \cs{CSharpE.Transform.Execution}.

\section{CSharpE.Transform.VisualStudio}

\begin{itemize}
\item tried creating custom language that "derives" from \cs{CSharp}; VS didn't like that
\item mention how I had to use the extern alias trick, which is not easy with NuGet
\end{itemize}

\section{CSharpE.Transform.MSBuild}

\section{Example extensions}
