\chapter{Implementation}

As has been explained before, the implementation should be a .NET library usable from C\#. While it would be possible to write such a library in another .NET language, C\#, as a general-purpose programming language, is suitable for this task, so it is the language used in the implementation.

One of the principles of the design of the system has been a focus on performance, especially when it comes to limiting executing the code of transformations. The implementation also sometimes considers performance, but generally speaking, maintainability and readability of code take precedence, especially at the method level. Because some of the code written this way might be performance-critical, the intention is to use profiling and optimize the found bottlenecks, but this has not been done in the current version.

\medskip

The implementation of the system is composed of four main projects:

\begin{itemize}
\item \cs{CSharpE.Syntax}, for representing code,
\item \cs{CSharpE.Transform}, for transforming code,
\item \cs{CSharpE.Transform.VisualStudio}, which supports using extensions at design-time in Visual Studio,
\item \cs{CSharpE.Transform.MSBuild}, which supports using extensions at build-time in MSBuild.
\end{itemize}

\section{CSharpE.Syntax}

The most complicated part of the job of \cs{CSharpE.Syntax} is to convert from C\# source code to CSharpE code representation and vice versa. To help with this, we can use Roslyn. With that, it is only necessary to convert between the Roslyn representation and the CSharpE representation, which is much easier. Also, by using Roslyn, we use the same code as the C\# compiler, which means there is no chance of introducing parsing bugs.

\medskip

Because CSharpE syntax nodes and Roslyn syntax nodes often have very close correspondence and because transformations often access only some parts of the syntax tree, a CSharpE syntax tree that is created from a Roslyn syntax tree acts as a lazy wrapper over it: CSharpE nodes are created from the corresponding Roslyn nodes only as necessary. In other words, when a CSharpE node is created from a Roslyn node, it stores the Roslyn node. When one of its child nodes is then accessed for the first time, it is created from the corresponding child of the Roslyn node.

Syntax nodes can also have properties that are not child syntax nodes and are not lazy. For example, the property \cs{string Name} of \cs{TypeDefinition} is one.

\medskip

A created CSharpE syntax node can then be modified by the user. Eventually, it will need to be converted back to C\# source code, which is once more done through Roslyn nodes: CSharpE nodes implement the internal interface \cs{ISyntaxWrapper<TSyntax>}, which can be seen in Listing~\ref{isyntaxwrapper}. The single method of this interface, \cs{GetWrapped}, is used to retrieve an up-to-date version of the Roslyn node (\cs{TSyntax}) for a CSharpE node. The \cs{changed} parameter is used by the \cs{GetWrapped} method of the parent to detect whether the current node changed since the parent called the \cs{GetWrapped} method of the child node last. Any other caller is required to pass a reference to \cs{null} for the parameter.

\begin{listing}
\begin{minted}{csharp}
internal interface ISyntaxWrapper<out TSyntax>
{
    TSyntax GetWrapped(ref bool? changed);
}
\end{minted}
\caption{Declaration of the ISyntaxWrapper interface}
\label{isyntaxwrapper}
\end{listing}

Another option would be to notify ancestor nodes when a node is modified. This way, a node that was not changed would not have to recompute the wrapped Roslyn node, which should be more efficient. Though this approach is more complicated and so it has not been implemented.

\medskip

\begin{listing}
\begin{minted}{csharp}
public sealed class Argument : SyntaxNode, ISyntaxWrapper<ArgumentSyntax>
{
    private ArgumentSyntax syntax;

    internal Argument(ArgumentSyntax syntax, SyntaxNode parent)
    {
        this.syntax = syntax ?? throw new ArgumentNullException(nameof(syntax));
        Name = syntax.NameColon?.Name.Identifier.ValueText;
        Parent = parent;
    }

    public Argument(Expression expression, string name = null)
    {
        Expression = expression;
        Name = name;
    }

    public string Name { get; set; }

    private Expression expression;
    public Expression Expression
    {
        get => expression ??
            (expression = FromRoslyn.Expression(syntax.Expression, this));
        set => SetNotNull(ref expression, value);
    }

    ArgumentSyntax ISyntaxWrapper<ArgumentSyntax>.GetWrapped(ref bool? changed)
    {
        GetAndResetChanged(ref changed);
        
        bool? thisChanged = false;
        var newExpression =
            expression?.GetWrapped(ref thisChanged) ?? syntax.Expression;

        if (syntax == null || thisChanged == true ||
            syntax.NameColon?.Name.Identifier.ValueText != Name)
        {
            syntax = RoslynSyntaxFactory.Argument(
                Name == null ? null : CSharpSyntaxFactory.NameColon(Name),
                default, newExpression);

            SetChanged(ref changed);
        }

        return syntax;
    }

    public static implicit operator Argument(Expression expression)
        => new Argument(expression);
}
\end{minted}
\caption{Simplified implementation of the Argument class}
\label{argument-source}
\end{listing}

Listing~\ref{argument-source} shows how a typical implementation of a \cs{SyntaxNode} looks like. Specifically, it shows simplified code of the \cs{Argument} class, which is used to represent an argument to a call. For example, the statement \cs{F(42, foo: null);} contains two arguments: \cs{42} and \cs{foo: null}. An argument is composed of an expression, an optional name and an optional ref kind (\cs{ref}, \cs{out} or \cs{in}). For brevity, the shown version of \cs{Argument} does not support arguments that have a ref kind. This means the class has two properties: the lazy \cs{Expression} and non-lazy \cs{Name}.

The implementation is composed of the following parts:

\begin{itemize}
\item Specification that the class directly inherits from the \cs{SyntaxNode} base class and that it implements the \cs{ISyntaxWrapper<TSyntax>} interface for Roslyn's \cs{ArgumentSyntax} type.

\item A field holding the most recent Roslyn syntax node, if any.

\item An internal constructor that creates an instance of the class from a Roslyn syntax node. Notice that the lazy property \cs{Expression} is not initialized here, while the non-lazy property \cs{Name} is. Another interesting point is how complicated the expression used to initialize \cs{Name} is, which shows that the CSharpE design is much simpler than the Roslyn design.

This constructor is used when a member of the \cs{Arguments} collection of \cs{InvocationExpression} is accessed for the first time.

\item A public constructor that can be used by the user to create a new instance of this class.

\item The \cs{Name} property. Because it is not lazy, it does not require any special behavior and so it can be an auto-property.

\item The \cs{Expression} property. Since it is lazy, when its value is read for the first time, it creates the \cs{Expression} node based on the expression of the Roslyn node. The \cs{FromRoslyn} class contains helper methods for converting Roslyn nodes to CSharpE nodes. In this case, it is used to create the correct type that derives from \cs{Expression} based on the Roslyn node.

The setter uses the helper method \cs{SetNotNull}, which checks that the passed in value is not \cs{null} and also ensures that the \cs{Parent} property of the expression node is correctly set.

\item The \cs{GetWrapped} method. It is an explicit interface implementation, because C\# does not allow implicit interface implementations through internal methods, only public ones, and this method should not be accessible by the user.

The method does the following:

\begin{enumerate}
\item Make sure that the value of the \cs{changed} parameter is set correctly when this method is called by the parent node by invoking the helper methods \cs{GetAndResetChanged} and \cs{SetChanged} at the appropriate places.
\item Call \cs{GetWrapped} on its lazy properties if they are initialized, otherwise use the corresponding child of the saved Roslyn node. While doing this, keep track of whether any lazy properties reported changes in the \cs{thisChanged} variable.
\item Check if a new Roslyn node needs to be created. This happens either because no Roslyn node has been created yet, or because changes occurred since the saved Roslyn node was created. Changes are detected by checking the \cs{thisChanged} variable for lazy properties and by comparing with the latest Roslyn node for non-lazy properties.
\item Create a new Roslyn node by using a factory method from the Roslyn \cs{SyntaxFactory} class (aliased as \cs{RoslynSyntaxFactory} because of a conflict with CSharpE \cs{SyntaxFactory}) and save it.
\item Finally, return the Roslyn node, which is now guaranteed to be up to date.
\end{enumerate}

\item An implicit conversion operator from \cs{Expression} to \cs{Argument}. This way, the common case where an argument to a call has only an expression, without a name or a ref kind, can be created more easily.
\end{itemize}

\section{CSharpE.Transform}

\section{CSharpE.Transform.VisualStudio}

\begin{itemize}
\item tried creating custom language that "derives" from \cs{CSharp}; VS didn't like that
\item mention how I had to use the extern alias trick, which is not easy with NuGet
\end{itemize}

\section{CSharpE.Transform.MSBuild}

\section{Example extensions}
