\chapter{Implementation}

As has been explained before, the implementation should be a .NET library usable from C\#. While it would be possible to write such a library in another .NET language, C\#, as a general-purpose programming language, is suitable for this task, so it is the language used in the implementation.

One of the principles of the design of the system has been a focus on performance, especially when it comes to limiting executing the code of transformations. The implementation also sometimes considers performance, but generally speaking, maintainability and readability of code take precedence, especially at the method level. Because some of the code written this way might be performance-critical, the intention is to use profiling and optimize the found bottlenecks, but this has not been done in the current version.

\medskip

The implementation of the system is composed of four main projects:

\begin{itemize}
\item \cs{CSharpE.Syntax}, for representing code,
\item \cs{CSharpE.Transform}, for transforming code,
\item \cs{CSharpE.Transform.VisualStudio}, which supports using extensions at design-time in Visual Studio,
\item \cs{CSharpE.Transform.MSBuild}, which supports using extensions at build-time in MSBuild.
\end{itemize}

\section{CSharpE.Syntax}

The most complicated part of the job of \cs{CSharpE.Syntax} is to convert from C\# source code to CSharpE code representation and vice versa. To help with this, we can use Roslyn. With that, it is only necessary to convert between the Roslyn representation and the CSharpE representation, which is much easier. Also, by using Roslyn, we use the same code as the C\# compiler, which means there is no chance of introducing parsing bugs.

\medskip

Because CSharpE syntax nodes and Roslyn syntax nodes often have very close correspondence and because transformations often access only some parts of the syntax tree, a CSharpE syntax tree that is created from a Roslyn syntax tree acts as a lazy wrapper over it: CSharpE nodes are created from the corresponding Roslyn nodes only as necessary. In other words, when a CSharpE node is created from a Roslyn node, it stores the Roslyn node. When one of its child nodes is then accessed for the first time, it is created from the corresponding child of the Roslyn node.

Syntax nodes can also have properties that are not child syntax nodes and are not lazy. For example, the property \cs{string Name} of \cs{TypeDefinition} is one.

\medskip

A created CSharpE syntax node can then be modified by the user. Eventually, it will need to be converted back to C\# source code, which is once more done through Roslyn nodes: CSharpE nodes implement the internal interface \cs{ISyntaxWrapper<TSyntax>}, which can be seen in Listing~\ref{isyntaxwrapper}. The single method of this interface, \cs{GetWrapped}, is used to retrieve an up-to-date version of the Roslyn node (\cs{TSyntax}) for a CSharpE node. The \cs{changed} parameter is used by the \cs{GetWrapped} method of the parent to detect whether the current node changed since the parent called the \cs{GetWrapped} method of the child node last. Any other caller is required to pass a reference to \cs{null} for the parameter.

\begin{listing}
\begin{minted}{csharp}
internal interface ISyntaxWrapper<out TSyntax>
{
    TSyntax GetWrapped(ref bool? changed);
}
\end{minted}
\caption{Declaration of the ISyntaxWrapper interface}
\label{isyntaxwrapper}
\end{listing}

Another option would be to notify ancestor nodes when a node is modified. This way, a node that was not changed would not have to recompute the wrapped Roslyn node, which should be more efficient. Though this approach is more complicated and so it has not been implemented.

\medskip

\todo{simplified source code of some very simple node type with a lazy and non-lazy property?}

A typical implementation of \cs{GetWrapped} will work like this:

\begin{enumerate}
\item 
\end{enumerate}

\section{CSharpE.Transform}

\section{CSharpE.Transform.VisualStudio}

\begin{itemize}
\item tried creating custom language that "derives" from \cs{CSharp}; VS didn't like that
\item mention how I had to use the extern alias trick, which is not easy with NuGet
\end{itemize}

\section{CSharpE.Transform.MSBuild}

\section{Example extensions}