\chapter{Possible approaches}

The goal of this work is to create a system for extending the C\# language. It should be possible to use it create a wide variety of extensions, including:

\begin{itemize}
\item Extension similar to an F\# type providers.
\item Extension similar to a PostSharp aspects.
\item Extension for entity types, which can generate constructors, members required for comparison and any other common boilerplate code.
\item Extension that modifies how existing language feature operates, for example, improving the time complexity of recursive iterators from quadratic to linear.
\item Extension that can be used to write a single method that performs numeric computation with any numeric type. This is easy to achieve with C++ templates, but impossible with C\# generics, because they don't have a way of specifying operators required by the method.
\item Extension that optimizes LINQ to Objects queries into efficient imperative code.
\item Extension that converts an \ac{AoS} into \iac{SoA}, to improve performance of memory accesses in some cases.
\end{itemize}

\todo{More use cases from existing code generators?}

Writing these extensions should be fairly easy and using extensions should not cause performance issues at design-time, build-time or run-time.

\medskip

Such a system will require two major parts: an \ac{API} for representing and modifying code used by extensions; and a component that drives extensions by applying their transformations at the appropriate time.

\section{Representing code}

The basic choices for representing C\# code in an \ac{API} are: as C\# code, as \ac{IL}, as some other form.

\ac{IL} can be ruled out, because it is hard to use due to its low-level nature, especially when it comes to features like \cs{async}-\cs{await} (the C\# compiler transforms \cs{async} methods into state machines at the \ac{IL} level).

Using a custom form would effectively require creating a new programming language (though one that does not necessarily have a textual form). The main disadvantage of doing that is that users would have to learn the new language and so it is generally the right choice only when no existing language is suitable.

This leaves the last option: using C\#. This approach ensures that extension authors are already familiar with the used language, they only need to learn the \ac{API} used to represent it. It also means that the output of the system will be in C\#, so existing tools for C\# can be used. One disadvantage is that extensions can only use features available from C\#. For example, the \cs{calli} \ac{IL} opcode is out of reach.

Putting this all together: C\# is the best choice for forming the basis of the \ac{API} for representing code for this system.

\medskip

Now that we know that the \ac{API} will represent C\# code, we need to decide how exactly it should look like:

\begin{itemize}
\item The \ac{API} should be mutable.

Immutable persistent \acp{API} (such as the one used by Roslyn) are useful when multiple versions of the same object need to be preserved (for example, for the "Undo" button in a code editor) or when multiple threads need access to the same object. Their disadvantage is that they make modifying objects harder: any change to a leaf of an object tree needs to be propagated to the root of the tree, creating new objects along the way.

This system does not need to keep multiple versions of objects, but it might be useful to parallelize it. For example, when two extensions modify different sections of code, it could be advantageous to execute them in parallel. Nevertheless, because of the focus on ease of use, a mutable \ac{API} is the better choice.

\item The \ac{API} should not reflect the syntax of C\# too closely.

In contrast with Roslyn, this \ac{API} does not need to be able to represent, preserve and generate every syntactic nuance of C\#, though it has to ensure the semantics of code is not changed. The basic examples of this are whitespace and comments.

A more advanced example is the difference between declaring variables together (\cs{int i, j;}) or separately (\cs{int i; int j;}). The \ac{API} could represent both syntactic forms the same: as a sequence of two variable declarations. 

Another example are parentheses in expressions. They are useful in the (infix) textual representation to change or emphasize the order of operations. But when representing an expression as a tree of objects, the order of operations is clear from the structure of the tree, so parentheses are not necessary.

\item The \ac{API} should respect the syntactic structure of C\#.

In contrast with the previous point, the \ac{API} should not be completely divorced from the syntax of C\#. For example, the general structure of a simple method declaration in C\# is: modifiers, return type, method name, parameters, method body. If possible, the \ac{API} should follow the same order.

\item The \ac{API} should make common code simple.

In the previous point, the list of elements of a method declaration was not complete: method declarations can also have attributes, type parameters and constraints. But many methods will not have these optional elements, and it should not be required to explicitly specify that a method does not have some of these elements.

Another example are method arguments. Method argument is commonly just an expression, but it can also have a modifier like \cs{ref} or a name. But generating a method call without these optional elements is likely going to be the most common case, so it should be simple and not burdened by the requirements of more complex cases.

\item The \ac{API} should be succinct.

The structure of real code is often complex, so the \ac{API} should handle generating such code. Because of this, it should avoid any unnecessary repetition, such as \ac{CodeDOM}'s \cs{Code} prefix, Roslyn's \cs{Expression} suffix or even repeated use of the \cs{new} operator. Roslyn's \cs{SyntaxFactory} with its \cs{static} methods serves as a fairly good model here: when combined with \cs{using static}, it leads to code that does not repeat itself much.

At the same time, the \ac{API} should not be too succinct by abbreviating names, for example the way the C function \cs{strpbrk} is named. This leads to names that are hard to understand and that also violate Framework Design Guidelines. \cite{fdg-naming}

\item The \ac{API} should seamlessly include semantic information.

Semantic information can be very useful, so it should be easily accessible. There shouldn't be a barrier similar to Roslyn's \cs{SemanticModel}, where syntactic information is included in a syntax tree, but semantic information has to be accessed separately.

On the other hand, accessing semantic information is more expensive in terms of performance than information based purely on syntax, so it might make sense to somehow discourage their use.

\item The \ac{API} has to be capable of handling invalid code.

For some extensions, it will be useful if its users can write code that is not valid C\#, which will then be transformed by the extension to make it valid. For example, an extension that automatically implements an interface could require that its users specify that interface in the list of interfaces a class implements, but then omit any implementation. That is not valid C\# code, but it will be filled out by the extensions.

Another reason is that extensions need to work at design-time, while the code is being edited, so that auto-completion can include members produced by extensions. This is especially important for extensions similar to F\# type providers, where generating new members is the reason why they exist.

\item The \ac{API} should not be language-independent.

Several existing \acp{API} for representing C\# code are language-independent, at least to some degree. But the goal of this work is only to make the C\# language extensible, so doing this it outside its scope.

\section{Transformations}
\end{itemize}