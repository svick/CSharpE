\chapter{Design}

Before starting actual design of the system, its name should be decided. This name would be used in names of namespaces, assemblies, NuGet packages and so on, so it should fit well with their requirements and conventions. The name should also be reasonably unique, easy to remember and not too long. The name chosen based on these principles is "CSharpE", meaning "C\#, extensible".

As explained in the previous chapter, this system has two main tasks: representing code and transforming code. This means it is natural to split the project into two main parts: \cs{CSharpE.Syntax} and \cs{CSharpE.Transform}, respectively.

\section{CSharpE.Syntax}

The \cs{CSharpE.Syntax} namespace contains all the types necessary for representing and modifying C\# code starting from the project level and going down all the way to the expression level. There is no representation for solutions, because extensions work at the project level, which means solutions are not necessary.

\todo{explain laziness and other non-API designs?}

\subsection{General principles}

There are some rules that apply though all levels of this \ac{API}:

\begin{itemize}
	
\item Types in this \ac{API} are regular mutable classes.

\item Types that represent nodes in the C\# syntax tree inherit from the common base class \cs{SyntaxNode}. This includes most types from the source file level down.

A syntax node can have only one parent node, to make sure the syntax tree is actually a tree and so that mutating a node does not affect another, seemingly unrelated part of the syntax tree. But this parent node is not exposed in the \ac{API}, for reasons explained in Section~\ref{no-parent}.

Syntax nodes can be deep cloned by calling the \cs{Clone} method, which is a generic extension method. It is that way to avoid having to cast its result to the correct type, which would be necessary if \cs{Clone} was a simple instance method on \cs{SyntaxNode}. Syntax nodes are also cloned instead of assigning a new parent node, to maintain the tree shape.

\item Collections of nodes are exposed as \cs{IList<T>}. This interface is the most flexible out of the commonly used collection interfaces in .NET. Using an interface means that the user is shielded from the implementation detail of which specific collection type is used.

\item The \ac{API} includes implicit conversion operators when appropriate. Specifically, they can be used to convert from a definition to a reference (e.g. from \cs{TypeDefinition} to \cs{IdentifierExpression} \linebreak[0] \todo[inline, inlinewidth=7.75cm, noinlinepar]{why not \cs{NamedTypeReference}?}) or from a node to a simple wrapper for that node (e.g. from \cs{Expression} to \cs{ExpressionStatement}).

\item There is a \cs{SyntaxFactory} type, which exists to make creating syntax nodes more succinct, when combined with \cs{using static}. For example, it means that to use the \cs{this} keyword, it is possible to write just \cs{This()}, instead of  \cs{new ThisExpression()}.

\end{itemize}

\subsection{Projects}

\subsection{Source files}

\subsection{Namespaces (?)}

\subsection{Types}

\subsection{Members}

\subsection{Statements}

\subsection{Expressions}

\subsection{References}

\section{CSharpE.Transform}

\label{no-parent}

Not just API!