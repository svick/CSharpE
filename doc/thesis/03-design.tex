\chapter{Design}

Before starting actual design of the system, its name should be decided. This name would be used in names of namespaces, assemblies, NuGet packages and so on, so it should fit well with their requirements and conventions. The name should also be reasonably unique, easy to remember and not too long. The name chosen based on these principles is "CSharpE", meaning "C\#, extensible".

As explained in the previous chapter, this system has two main tasks: representing code and transforming code. This means it is natural to split the project into two main parts: \cs{CSharpE.Syntax} and \cs{CSharpE.Transform}, respectively.

\section{CSharpE.Syntax}

The \cs{CSharpE.Syntax} namespace contains all the types necessary for representing and modifying C\# code starting from the project level and going down all the way to the expression level. There is no representation for solutions, because extensions work at the project level, which means solutions are not necessary.

\subsection{Example}

Before explaining details about the design of this namespace, it might be useful to see an example of its usage. Listing~\ref{csharpesyntax-example} shows how the running example from Section~\ref{running-example} could be implemented using this \ac{API}. Notice how the code is very short, when compared with the previously shown examples from Chapter~\ref{background}, without resorting to a custom language that mixes two programs, like \ac{T4} does. This is thanks to following the guidelines from Section~\ref{representing-code}.

\begin{listing}
\inputminted[firstline=15,lastline=31]{csharp}{samples/CSharpE.Syntax/Program.cs}
\caption{CSharpE.Syntax example}
\label{csharpesyntax-example}
\end{listing}

Specifically, what the code does is to create a project (\cs{Project}) containing one source file (\cs{SourceFile}) that contains the initial code. Then it finds classes (\cs{ClassDefinition}) in the project and for each of them, adds \cs{IEquatable<T>} to the list of base types and also changes all its fields (\cs{FieldDefinition}) to auto-implemented properties (\cs{PropertyDefinition}).

The rest of this chapter describes the \ac{API} in detail.

\subsection{General principles}

There are some rules that apply though all levels of this \ac{API}:

\begin{itemize}
	
\item Types in this \ac{API} are regular mutable classes.

\item Types that represent nodes in the C\# syntax tree inherit from the common base class \cs{SyntaxNode}. This includes most types from the source file level down.

A syntax node can have only one parent node, to make sure the syntax tree is actually a tree and so that mutating a node does not affect another, seemingly unrelated part of the syntax tree. But this parent node is not exposed in the \ac{API}, for reasons explained in Section~\ref{no-parent}.

Syntax nodes can be deep cloned by calling the \cs{Clone} method, which is a generic extension method. It is that way to avoid having to cast its result to the correct type, which would be necessary if \cs{Clone} was a simple instance method on \cs{SyntaxNode}. Syntax nodes are also cloned instead of assigning a new parent node, to maintain the tree shape.

\item Collections of nodes are usually exposed as properties of type \cs{IList<T>}. This interface is the most flexible out of the commonly used collection interfaces in .NET. Using an interface means that the user is shielded from the implementation detail of which specific collection type is used.

For convenience, some collections are also exposed on higher levels as methods. For example, \cs{TypeDefintion} contains the \cs{Methods} property, while \cs{SourceFile} and \cs{Project} contain the \cs{GetMethods} method, which returns methods from the whole file or project, respectively. Such methods return \cs{IEnumerable<T>}, because it does not make sense to for example add a method directly to a file or a project, it has to be added to a specific type.

\item The \ac{API} includes implicit conversion operators when appropriate. Specifically, they can be used to convert from a definition to a reference (e.g. from \cs{TypeDefinition} to \cs{NamedTypeReference}) or from a node to a simple wrapper for that node (e.g. from \cs{Expression} to \cs{ExpressionStatement}).

Using implicit conversions makes code shorter, but also harder to understand, because it is an operation that is not visible in the code. For this reason, all implicit conversion operators have an alternative form, usually a constructor of the target type.

\item There is a \cs{SyntaxFactory} type, which exists to make creating syntax nodes more succinct, when combined with \cs{using static}. For example, it means that to use the \cs{this} keyword, it is possible to write just \cs{This()}, instead of  \cs{new ThisExpression()}.

\end{itemize}

Listing~\ref{syntax-types} shows inheritance hierarchy of the \cs{CSharpE.Syntax} namespace.

\begin{listing}
	
\dirtree{%
.1 .
.2 Project.
.2 NamespaceOrTypeDefinition.
.2 SyntaxNode.
.3 SourceFile.
.3 NamespaceDefition.
.3 MemberDefinition.
.4 BaseTypeDefinition.
.5 TypeDefinition.
.6 ClassDefinition.
.6 StructDefinition.
.6 InterfaceDefinition.
.5 EnumDefinition.
.5 DelegateDefinition.
}

\caption{Inheritance hierarchy of commonly used types in the \cs{CSharpE.Syntax} namespace}
\label{syntax-types}
	
\end{listing}


\subsection{Projects}

At the top of this \ac{API} is the \cs{Project} class, which represents a collection of C\# source files and library references. It also contains helper methods for accessing types from all files within a project, for extensions that do not care about which file contains which type.

The \cs{Project} class is also point of interoperation between this \ac{API} and Roslyn: \cs{Project} can be constructed from a \cs{CSharpCompilation} and it also exposes a \cs{CSharpCompilation} as a property.

\subsection{Source files}

Each C\# source file in the project is represented as an instance of the \cs{SourceFile} class. A source file has name, text and a list of members, which are namespace and type definitions.

\medskip

The obvious object-oriented way to model this list would be to have a common base class shared by the namespace definition class and the type definition class. The problem with this is that types can be members of other types, while namespaces cannot. So, we would want type definition to inherit from the member definition class (along with other kinds of type members), and namespace definition to not inherit from that class. But this is not possible, because .NET does not allow multiple inheritance of classes.

There are several options of how to resolve this:

\begin{itemize}
\item Make the common base class of namespace definition and type definition into an interface, since multiple inheritance of interfaces is allowed. This interface would not be very useful on its own, since namespace and type definitions are not very similar and generally require different processing.
\item Make namespace definition inherit from the member definition class. This would allow adding namespace definitions as members of types, which is not valid C\#, so it is undesirable.
\item Don't have namespace definitions in the syntax tree at all, instead the namespace of a type definition is surfaced as a property. This is how namespaces are represented in \ac{IL} and Reflection. The problem with this is that deviates from the syntax of C\# too much, which could be confusing to users.
\item Use a different class for representing nested type definitions. This way, there is no issue with multiple inheritance, because each base class would be inherited by a different class. The problem here is that users will probably expect that nested types behave the same as regular types, since both have the same syntax in C\#.
\item Instead of a common base type, use a discriminated union. The biggest issue with this approach is that it is not commonly used in object-oriented design and so it might be unfamiliar to C\# programmers and it also would not fit well with the rest of this object-oriented \ac{API}.
\end{itemize}

The option chosen from the above was to use discriminated union \cs{struct} called \cs{NamespaceOrTypeDefinition}, because it fits the best with the expected usage pattern of these types, where nested types and regular types are handled the same, while namespaces and types are handled in separate code paths.

\medskip

Notice that \cs{using} directives are not exposed in the \ac{API} at all, because they are managed automatically. This makes the \ac{API} easier to use, at the cost of preventing users from choosing which syntax should be used, which is consistent with the principles outlined in the previous chapter.

\subsection{Types}

The types that can be defined in C\# are classes, structs, interfaces, enums and delegates. Classes, structs and interfaces are very similar in that all three can be generic, have a list of base types and have various members. Also, especially when it comes to classes and structs, it could make sense fairly often to manipulate them in the same way. 

This means that a reasonable design would be to have the types for classes, structs and interfaces inherit from a common base class and this base class, along with the types for enums and delegates, should inherit from another base class. The problem with this design is naming: there is no established name that would apply to classes, structs and interfaces, but not to enums and delegates. For this reason, the names chosen for the two base classes are \cs{TypeDefinition} and \cs{BaseTypeDefinition}.

\medskip

For a \cs{TypeDefinition}, all its members are contained in the \cs{Members} list, while various kinds of members like fields or methods are also contained in their own lists (for example, \cs{Fields} or \cs{Methods}). These smaller lists are kept synchronized with the main list of members. This means these lists effectively act as filtered views on the main list.

To make adding new members easier, \cs{TypeDefinition} also contains methods like \cs{AddFields}. For example, consider the following code:

\begin{minted}{csharp}
var field = new FieldDefinition(...);
type.Fields.Add(field);
\end{minted}

By using the \cs{AddFields} method, that code can be simplified to:

\begin{minted}{csharp}
var field = type.AddField(...);
\end{minted}

\subsection{Members}

Class, struct and interface definitions can contain various kinds of members, namely fields, methods, properties, events, indexers, operators, constructors, destructors (also known as finalizers) and nested type definitions. Not all kinds of members are valid for all three kinds of types, but since invalid members might be useful to some extensions, the \ac{API} still allows them.

All kinds of members can have modifiers. While in source, member modifiers can be defined in different order (for example, both \cs{public static} and \cs{static public} are valid modifiers for a method), this order does not make a difference. For this reason, this \ac{API} represents all modifiers using a single flags enum, \cs{MemberModifiers}. 

Because manipulating flags enums using bitwise operators can be cumbersome, the \ac{API} also includes helper read-write properties for most valid modifiers for each kind of member. The exception to this are access modifiers. Because a member can have only one kind of declared accessibility (which includes all the access modifiers on their own and also the combinations \cs{protected internal} and \cs{private protected}), access modifiers are surfaced as a read-write property named \cs{Accessibility}, along with a read-only property for each kind of declared accessibility.

\todo{MemberDefinition}

\subsection{Statements}

\subsection{Expressions}

\subsection{References}

\section{CSharpE.Transform}

\todo{Not just API!}

\label{no-parent}