\chapter{Design}

Before starting actual design of the system, its name should be decided. This name would be used in names of namespaces, assemblies, NuGet packages and so on, so it should fit well with their requirements and conventions. The name should also be reasonably unique, easy to remember and not too long. The name chosen based on these principles is "CSharpE", meaning "C\#, extensible".

As explained in the previous chapter, this system has two main tasks: representing code and transforming code. This means it is natural to split the project into two main parts: \cs{CSharpE.Syntax} and \cs{CSharpE.Transform}, respectively.

\section{CSharpE.Syntax}

The \cs{CSharpE.Syntax} namespace contains all the types necessary for representing and modifying C\# code starting from the project level and going down all the way to the expression level. There is no representation for solutions, because extensions work at the project level, which means solutions are not necessary.

Listing~\ref{syntax-types} shows inheritance hierarchy of this namespace.

\begin{listing}

\dirtree{%
.1 .
.2 Project.
.2 NamespaceOrTypeDefinition.
.2 SyntaxNode.
.3 SourceFile.
.3 NamespaceDefition.
.3 MemberDefinition.
.4 BaseTypeDefinition.
.5 TypeDefinition.
.6 ClassDefinition.
.6 StructDefinition.
.6 InterfaceDefinition.
.5 EnumDefinition.
.5 DelegateDefinition.
}

\caption{Inheritance hierarchy of commonly used types in the \cs{CSharpE.Syntax} namespace}
\label{syntax-types}

\end{listing}

\subsection{General principles}

There are some rules that apply though all levels of this \ac{API}:

\begin{itemize}
	
\item Types in this \ac{API} are regular mutable classes.

\item Types that represent nodes in the C\# syntax tree inherit from the common base class \cs{SyntaxNode}. This includes most types from the source file level down.

A syntax node can have only one parent node, to make sure the syntax tree is actually a tree and so that mutating a node does not affect another, seemingly unrelated part of the syntax tree. But this parent node is not exposed in the \ac{API}, for reasons explained in Section~\ref{no-parent}.

Syntax nodes can be deep cloned by calling the \cs{Clone} method, which is a generic extension method. It is that way to avoid having to cast its result to the correct type, which would be necessary if \cs{Clone} was a simple instance method on \cs{SyntaxNode}. Syntax nodes are also cloned instead of assigning a new parent node, to maintain the tree shape.

\item Collections of nodes are usually exposed as \cs{IList<T>}. This interface is the most flexible out of the commonly used collection interfaces in .NET. Using an interface means that the user is shielded from the implementation detail of which specific collection type is used.

\item The \ac{API} includes implicit conversion operators when appropriate. Specifically, they can be used to convert from a definition to a reference (e.g. from \cs{TypeDefinition} to \cs{IdentifierExpression} \linebreak[0] \todo[inline, inlinewidth=7.75cm, noinlinepar]{why not \cs{NamedTypeReference}?}) or from a node to a simple wrapper for that node (e.g. from \cs{Expression} to \cs{ExpressionStatement}).

Using implicit conversions makes code shorter, but also harder to understand, because it is an operation that is not visible in the code. For this reason, all implicit conversion operators have an alternative form, usually a constructor of the target type.

\item There is a \cs{SyntaxFactory} type, which exists to make creating syntax nodes more succinct, when combined with \cs{using static}. For example, it means that to use the \cs{this} keyword, it is possible to write just \cs{This()}, instead of  \cs{new ThisExpression()}.

\end{itemize}

\subsection{Projects}

At the top of this \ac{API} is the \cs{Project} class, which represents a collection of C\# source files and library references. It also contains helper methods for accessing types from all files within a project, for extensions that do not care about which file contains which type.

The \cs{Project} class is also point of interoperation between this \ac{API} and Roslyn: \cs{Project} can be constructed from a \cs{CSharpCompilation} and it also exposes a \cs{CSharpCompilation} as a property.

\subsection{Source files}

Each C\# source file in the project is represented as an instance of the \cs{SourceFile} class. A source file has name, text and a list of members, which are namespace and type definitions.

The object-oriented way to model this list would be to have a common base class or interface shared by \cs{NamespaceDefition} and \cs{BaseTypeDefinition} (see next section) and use that for items in the list. But because namespace and type definitions do not share many members and there are only two of them, it is likely users would write code specific to each of the two. For this reason, the list instead contains instances of a \cs{struct} named \cs{NamespaceOrTypeDefinition}, which is effectively a discriminated union of the two types. This is an approach common in functional programming.

Since this design is not very user-friendly, it is worth considering other options. One of them would be not having namespace definitions part of the syntax tree, but instead make namespace a property of type definition, which is how namespaces are represented in \ac{IL} and Reflection. The main issue with this approach is that it would diverge too much from the structure of C\# code, which could be confusing to users. For this reason, this option was not chosen.

Notice that \cs{using} directives are not exposed in the \ac{API} at all, because they are managed automatically by the \ac{API}. This makes the \ac{API} easier to use, at the cost of preventing users from choosing which syntax should be used, which is consistent with the principles outlined in the previous Chapter.

\subsection{Types}

The types that can be declared in C\# are classes, structs, interfaces, enums and delegates. Classes, structs and interfaces are very similar in that all three can be generic, have a list of base types and have various members. Also, especially when it comes to classes and structs, it could make sense fairly often to manipulate them in the same way. 

This means that a reasonable design would be to have the types for classes, structs and interfaces inherit from a common base class and this base class, along with the types for enums and delegates, should inherit from another base class. The problem with this design is naming: there is no established name that would apply to classes, structs and interfaces, but not to enums and delegates. For this reason, the names chosen for the two base classes are \cs{TypeDefinition} and \cs{BaseTypeDefinition}.

\todo{allowed modifiers and members}

\subsection{Members}

\todo{incl. design of modifiers}

\subsection{Statements}

\subsection{Expressions}

\subsection{References}

\section{CSharpE.Transform}

\todo{Not just API!}

\label{no-parent}